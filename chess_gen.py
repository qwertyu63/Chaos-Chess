# This program randomly generates chess variants.
# It randomly selects the board size and then generates an assortment of pieces to fill it.
# It considers the board size when creating pieces to create.
# It runs a check to make sure all pawns are protected in the opening layout, starting over if it isn't.
# It then displays the new variant in an easily readable format.

from random import randint
from math import ceil
from copy import deepcopy

# Listing the atoms pieces can be made from.
nor_atoms = ["W", "F", "D", "A", "N", "R", "B"]
big_atoms = ["C", "Z", "H"]
long_atoms = ["M", "G", "S"]

atom_values = [2, 2, 1, 1, 3, 4, 5, 3, 2, 1, 5, 2, 2]
atom_bind = [0, 1, 2, 3, 0, 0, 1, 1, 0, 0, 0, 1, 2]

atom_sight = [0, 1, "", "", 2, 0, 1, 3, "", "", 2, "", ""]
extra_sight = ["", "", 0, 2, 1, "", "", "", 3, 0, 1, 0, 0]

halves = [["fb","s"], ["f","b"], ["fb","s"], ["f","b"], ["f","b"], ["fb","s"], ["f","b"]]

long_convert = {"M": "NN", "G": "DD", "S": "AA"}

# This is a list of default piece names.
prebuild = {
    "W": "Wazir", 
    "F": "Ferz", 
    "D": "Dabbaba", 
    "A": "Alfil", 
    "N": "Knight", 
    "R": "Rook", 
    "B": "Bishop", 
    "C": "Camel", 
    "Z": "Zebra", 
    "WF": "Man", 
    "WD": "Woodman", 
    "WA": "Phoenix", 
    "WN": "Marquis", 
    "WB": "Archbishop", 
    "WC": "Sorcerer", 
    "WZ": "Ranger", 
    "FD": "Scout", 
    "FA": "Preacher", 
    "FN": "Priest", 
    "FR": "Tower", 
    "FC": "Wizard", 
    "FZ": "Druid", 
    "DA": "Spider", 
    "DN": "Archer", 
    "DR": "Acrobat", 
    "DB": "Paladin", 
    "AN": "Hunter", 
    "AR": "Soldier", 
    "AB": "Shaman", 
    "NR": "Chancellor", 
    "NB": "Cardinal", 
    "NC": "Wildebeest", 
    "NZ": "Moose", 
    "NH": "Warlord", 
    "RB": "Queen", 
    "RC": "Barbarian", 
    "RZ": "Monk", 
    "BC": "Caliph", 
    "BZ": "Witch", 
    "CZ": "Ram", 
    "WFN": "Centaur", 
    "DAN": "Squirrel", 
    "WDA": "Champion", 
    "NCZ": "Dragon", 
    "NN": "Nightrider", 
    "DD": "Warmachine", 
    "AA": "Elephant Rider", 
    "BNN": "Unicorn", 
    "RNN": "Pegasus",
    "tFR": "Gryphon", 
    "tWB": "Anaca", 
}

# Chaos determines the odds of any specific piece being a Chaos piece, with strange movements.
chaos = 3

def gen_piece(parts):
    code = []
    value = 0
    bind = 9
    while parts:
        roll = randint(0, len(atoms)-1)
        if clearcheck(atoms[roll], code):
            code.append(atoms[roll])
        parts -= 1
    return compile_piece(code)

def clearcheck(new, list):
    '''Given a new move and a list of existing moves, this fuctions determines if that move is redundant. It also rejects 50% of long leapers, to make those moves rarer.'''
    if len(list) == 0:
        return True
    if new in list:
        return False
    locks = {
        "W": "R", "R": "W", 
        "F": "B", "B": "F", 
        "N": "M", "M": "N", 
        "D": "G", "G": "D", 
        "A": "S", "S": "A", 
    }
    if new in locks.keys():
        if locks[new] in list:
            return False
    if new in long_atoms:
        return bool(randint(0, 1))
    return True

def compile_piece(code):
    '''This function takes the move code generated by other functions and converts it into a full piece, with a name, value and sight information.'''
    label = ""
    value = -1
    bind = 9
    sight = [[], []]
    for i in range(len(atoms)-1):
        if atoms[i] in code:
            if atoms[i] in long_atoms:
                label += long_convert[atoms[i]]
            else:
                label += atoms[i]
            value += atom_values[i]+1
            if bind > atom_bind[i]:
                bind = atom_bind[i]
            if atom_sight[i] != "":
                sight[0].append(atom_sight[i])
            if extra_sight[i] != "":
                sight[1].append(extra_sight[i])
    value -= bind
    if label == "H":
        value = 0
    name = label
    if label in prebuild.keys():
        name = prebuild[label]
    else:
        name = make_name(label)
    return (label, value, name, sight)

def chaos_piece():
    "This function chooses what kind of chaos piece to use."
    form = randint(1,3)
    if form == 1:
        roll = [[1,1], [1,1], [2,1], [1,2]][randint(0,3)]
        partA = roll[0]
        partB = roll[1]
        if partB <= 0: partB = 1
        return fusion_piece(gen_piece(partA), gen_piece(partB))
    elif form == 2:
        rand = randint(1,2)
        return half_piece(gen_piece(rand), gen_piece(1))
    elif form == 3:
        return bent_rider()

def long_swap(move, dire = True):
    hold = move
    if dire:
        if "NN" in move:
            hold = hold.replace("NN", "M")
        if "DD" in move:
            hold = hold.replace("DD", "S")
        if "AA" in move:
            hold = hold.replace("AA", "S")
        return hold
    else:
        if "M" in move:
            hold = hold.replace("M", "NN")
        if "G" in move:
            hold = hold.replace("G", "DD")
        if "S" in move:
            hold = hold.replace("S", "AA")
        return hold

def fusion_piece(pieceA, pieceB):
    '''This function combines two pieces to form a Fusion piece that movess like pieceA and attacks like pieceB.'''
    label = ""
    moveA, moveB = long_swap(pieceA[0]), long_swap(pieceB[0])
    for i in moveA:
        if i in moveB:
            label+=i
            moveA = moveA.replace(i, "")
            moveB = moveB.replace(i, "")
    if len(moveA)!=0:
        for i in moveA[0]:
            label += (i + "m")
    if len(moveB)!=0:
        for i in moveB[0]:
            label += (i + "c")
    value = ceil(pieceA[1]/2) + (pieceB[1] // 2)
    name = chop_name(pieceA[2], pieceB[2])
    sight = pieceB[3]
    return (long_swap(label, False), value, name, sight)

def half_piece(pieceA, pieceB):
    '''This function combines two pieces to form a Fusion piece that is pieceA, but can also move OR attack (not both) like pieceB.'''
    split = ["c", "m"][randint(0,1)]
    label = pieceA[0]
    if pieceB[0] == "":
        # This bit of code routes around an unsolved bug where pieceB fails to create.
        return pieceA
    if pieceB[0] in pieceA[0] or (pieceB[0] == "W" and "R" in pieceA[0]) or (pieceB[0] == "F" and "B" in pieceA[0]):
        # This aborts the piece if pieceB is redundant.
        return pieceA
    tag = pieceB[0] + split
    label += tag
    value = pieceA[1] + (pieceB[1] // 2)
    if tag[0] != "A":
        tag = tag[0] + (["A", "E", "I", "O", "U"][randint(0, 4)]) + tag[1]
    name = pieceA[2] + tag.lower()
    sight = pieceA[3]
    if split == "c":
        sight += pieceB[3]
    return (long_swap(label, False), value, name, sight)

def bent_rider():
    # This code generates a bent rider piece.
    rollA = randint(0,4)
    partA = ["W", "F", "D", "A", "N"][rollA]
    partB = ["R", "B", "M", "G", "S"][randint(0,4)]
    label = "t["+partA+partB+"]"
    name = "t"+partA+partB
    if name in ["tWR", "tFB", "tNM", "tDG", "tAS"]:
        name = name[2]
        label = label[3]
    label = long_swap(label, False)
    sight = [[],[]]

    if atom_sight[rollA] != "":
        sight[0].append(atom_sight[rollA])
    if extra_sight[rollA] != "":
        sight[1].append(extra_sight[rollA])

    if name in prebuild.keys():
        name = prebuild[name]
    else:
        name = make_name(name)

    return (label, 9, name, sight)

def chop_name(nameA, nameB):
    name = nameA[0:ceil(len(nameA)/2)]
    name += nameB[(len(nameB)//2):len(nameB)]
    return name

def make_name(word):
    '''This function generates a name for a piece, using the letters from its movement code.'''
    name = ""
    spaces = len(word)
    if spaces > 3: spaces = 3
    for i in word[0:spaces]:
        name += i
        if i not in ["A", "E", "I", "O", "U"]:
            name += ["A", "E", "I", "O", "U"][randint(0, 4)]
    return name.title()

def getalpha(name, code):
    '''This function selects a letter to represent a piece. Some pieces have reserved letters. Other pieces get the first letter in their name that isn't reserved.'''
    if len(code) == 1:
        return code
    if code == "RB":
        return "Q"
    step = 0
    while True:
        if step >= len(name):
            try:
                return default.pop(0)
            except IndexError:
                return "G"
        elif name[step].upper() in piece_label or name[step].upper() in atoms or name[step].upper() in ["Q", "P"]:
            step+=1
        else:
            if name[step].upper() in default:
                default.remove(name[step].upper())
            return name[step].upper()

def game_name_check(name, value, code):
    '''This function tracks the names and values of pieces to eventually name the chess variant.'''
    global name_hold, name_value, backup_name, backup_value
    if code not in prebuild.keys():
        if value >= name_value:
            name_hold = name
            name_value = value
    else:
        if value >= backup_value:
            backup_name = name
            backup_value = value

def pawn_vision(list, slot, numbers):
    '''This function checks which pawns the specified piece can see in the opening setup.'''
    for i in numbers:
        if slot-i>=0:
            list[slot-i]=True
        if slot+i<len(list):
            list[slot-i]=True
    return list

# ---------------------------------
# This is the start of the loop that only breaks when a valid variant is generated.
# ---------------------------------

while True:
    # This is a placeholder for where the name of the variant will be generated.
    game_name = "Chaos Chess"
    name_hold = ""
    name_value = 0
    backup_name = ""
    backup_value = 0

    default = ["X", "J", "V", "Y"]

    # Setting the size and arrangement of the board.
    files = randint(6, 13)
    ranks = randint(6, 13)
    camp = 1
    if ranks >= randint(9, 12):
        camp = 2
    sym = False
    if files >= randint(6, 10):
        sym = True
    mirror = bool(randint(0, 1))

    # This generates a list of moves to be used. The longer range moves are only used if the board is big enough.
    atoms = deepcopy(nor_atoms)
    if ranks-camp > 5:
        atoms += big_atoms
        if randint(0, 1):
            atoms += long_atoms

    # Create a list of pieces.
    pieces = {"King": "K"}
    piece_desc = ["K: King (WF)"]
    piece_label = ["K"]
    piece_sight = {"K": [[0, 1], []]}

    # Determine how many pieces need to be created.
    piece_count = (files * camp)
    if sym:
        piece_count = piece_count//2
    else:
        piece_count -= 1

    # Start creating the pieces.
    die = [1, 1, 2, 2, 3]
    while piece_count:
        parts = die[randint(0, len(die)-1)]
        if randint(1,20) <= chaos:
            new_piece = chaos_piece()
        else:
            new_piece = gen_piece(parts)
        if new_piece[1] > 0 and new_piece[1] < 11:
            if new_piece[0] not in pieces.keys():
                label = getalpha(new_piece[2], new_piece[0])
                pieces[new_piece[0]] = label
                desc = label + ": "+new_piece[2]+ " (" + new_piece[0] + ")"
                piece_desc.append(desc)
                piece_sight[label] = new_piece[3]     
            else:
                label = pieces[new_piece[0]]
            piece_label += label
            game_name_check(new_piece[2], new_piece[1], new_piece[0])
            piece_count-=1

    # Creating the initial board state.
    home_row = ["-"] * files
    king_home = (files//2)

    counter = 1
    for i in range(0, king_home):
        home_row[i] = piece_label[counter]
        counter += 1

    if not sym:
        for i in range(king_home+1, files):
            home_row[i] = piece_label[counter]
            counter += 1
    else:
        new_count = 1
        for i in range(1, king_home+1):
            home_row[i*-1] = piece_label[new_count]
            new_count += 1

    home_row[king_home] = "K"

    if camp == 2:
        extra_row = ["-"] * files
        if not sym:
            for i in range(0, files):
                extra_row[i] = piece_label[counter]
                counter += 1
        else:
            try:
                for i in range(0, king_home):
                    extra_row[i] = piece_label[counter]
                    extra_row[(i+1)*-1] = piece_label[counter]
                    counter += 1
                if extra_row[king_home] == "-":
                    extra_row[king_home] = piece_label[counter]
            except IndexError:
                print("Files: "+str(files))
                print("Pieces: "+str(piece_label))
                print("Count: "+str(counter))

    # This section checks to make sure every pawn is protected in the opening lineup.
    vision_field = [False] * files
    if camp == 1:
        for i, j in enumerate(home_row):
            vision_field = pawn_vision(vision_field, i, piece_sight[j][0])
    if camp == 2:
        for i, j in enumerate(extra_row):
            vision_field = pawn_vision(vision_field, i, piece_sight[j][0])
        for i, j in enumerate(home_row):
            vision_field = pawn_vision(vision_field, i, piece_sight[j][1])

    # Finally, this checks if every pawn is protected in the opening layout. If they all are, it approves the variant.
    success = True
    for i in vision_field:
        if not i:
            success = False
    if success:
        break

# -------------------------
# This is the end of the loop. If we get here, a valid chess variant has been created.
# -------------------------

# Creating and naming the variant. It is named after the strongest piece that doesn't have a predefined name; if no such pieces exist, it defaults to the strongest piece overall.
if name_hold:
    game_name = name_hold + " Chess"
else:
    game_name = backup_name + " Chess"
print(game_name + ":\n")

ranks_left = ranks

letters = "abcdefghijklmnopqrstuvwxyz"
if ranks >= 10:
    print("   ", end="")
else:
    print("  ", end="")
for i in range(0, files):
    print(letters[i], end="")
print()

# Displaying the initial board state. 
rank_count=ranks

def label_rank(count):
    if ranks >= 10 and count < 10:
        print(" "+str(rank_count)+" ", end="")
    else:
        print(str(rank_count)+" ", end="")
    return count-1

rank_count = label_rank(rank_count)
for i in home_row:
    print(i.lower(), end="")
print()
ranks_left -= 2

if camp == 2:
    rank_count = label_rank(rank_count)
    for i in extra_row:
        print(i.lower(), end="")
    print()
    ranks_left -= 2

rank_count = label_rank(rank_count)
for i in ["P"] * files:
    print(i.lower(), end="")
print()
ranks_left -= 2

while ranks_left != 0:
    rank_count = label_rank(rank_count)
    for i in ["-"] * files:
        print(i, end="")
    print()
    ranks_left -= 1

if mirror:
    home_row.reverse()
    if camp == 2:
        extra_row.reverse()

rank_count = label_rank(rank_count)
for i in ["P"] * files:
    print(i, end="")
print()

if camp == 2:
    rank_count = label_rank(rank_count)
    for i in extra_row:
        print(i, end="")
    print()

rank_count = label_rank(rank_count)
for i in home_row:
    print(i, end="")
print()

print("\nPiece List:")

entries = []
for i in piece_desc:
    if i not in entries:
        entries.append(i)
        print(i)
